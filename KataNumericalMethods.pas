//Chat Gpt
//тест 22.01.2025 jdoodle.com
program NumericalMethods;

uses
  crt, math;

{ Функция для вычисления значения функции f(x) = x^2 - 2, корень которой мы ищем }
function f(x: Real): Real;
begin
  f := x * x - 2;  { x^2 - 2, ищем корень из 2 }
end;

{ Производная функции f(x), необходимая для метода Ньютона }
function df(x: Real): Real;
begin
  df := 2 * x;  { Производная от x^2 - 2 }
end;

{ Метод Ньютона для нахождения корня уравнения f(x) = 0 }
function NewtonMethod(initialGuess: Real; epsilon: Real): Real;
var
  x, delta: Real;
begin
  x := initialGuess;
  repeat
    delta := f(x) / df(x);  { Вычисляем шаг для корректировки значения }
    x := x - delta;  { Обновляем значение x на основе шага }
  until abs(delta) < epsilon;  { Останавливаемся, когда шаг достаточно мал }
  NewtonMethod := x;
end;

{ Метод бисекции для нахождения корня функции f(x) = 0 на отрезке [a, b] }
function BisectionMethod(a, b: Real; epsilon: Real): Real;
var
  c: Real;
begin
  repeat
    c := (a + b) / 2;  { Находим середину отрезка }
    if f(c) = 0 then
      break;  { Если c — корень, выходим }
    if f(a) * f(c) < 0 then
      b := c  { Если корень на отрезке [a, c], сужаем отрезок }
    else
      a := c;  { Если корень на отрезке [c, b], сужаем отрезок }
  until (b - a) / 2 < epsilon;  { Пока длина отрезка больше epsilon }
  BisectionMethod := c;
end;

{ Процедура для отображения главного меню }
procedure ShowMenu;
begin
  clrscr;
  writeln('Меню числовых методов:');
  writeln('1. Метод Ньютона');
  writeln('2. Метод бисекции');
  writeln('3. Выход');
  writeln;
  write('Выберите метод (1-3): ');
end;

{ Основная процедура программы }
var
  choice: Integer;
  result: Real;
  a, b, epsilon, initialGuess: Real;
begin
  repeat
    ShowMenu;  { Показать меню }
    readln(choice);  { Чтение выбора пользователя }
    
    case choice of
      1: begin
        { Метод Ньютона: начинаем с догадки 1.0, точность 0.0001 }
        initialGuess := 1.0;
        epsilon := 0.0001;
        result := NewtonMethod(initialGuess, epsilon);
        writeln('Решение методом Ньютона: ', result:0:6);
      end;
      2: begin
        { Метод бисекции: отрезок [1, 2], точность 0.0001 }
        a := 1.0;
        b := 2.0;
        epsilon := 0.0001;
        result := BisectionMethod(a, b, epsilon);
        writeln('Решение методом бисекции: ', result:0:6);
      end;
      3: begin
        writeln('Выход из программы...');
      end;
    else
      writeln('Неверный выбор. Попробуйте снова.');
    end;
    
    writeln;
    write('Нажмите Enter для продолжения...');
    readln;
    
  until choice = 3;  { Выход из программы, если выбран пункт 3 }
end.

//Привет! Можешь написать красивый приветственный код на паскаль, реализующий числовые методы с пояснениями и комментариями. Было бы здорово если бы этот код показывал преимущества императивной парадигмы программирования, при этом был бы не очень объемным и реализовывался в консоли. Если будет меню - это будет преимуществом  
//Привет! Конечно, давай создадим пример программы на языке Паскаль, которая демонстрирует преимущества императивной парадигмы программирования с использованием числовых методов. Я реализую простое консольное приложение, которое будет иметь меню с несколькими числовыми методами (например, метод Ньютона для нахождения корня уравнения и метод бисекции). Код будет хорошо комментирован для пояснений.
// Пояснения к коду:

//    Императивный стиль: Код написан в императивном стиле, где мы явно контролируем ход программы через последовательные инструкции. Например, в методах Ньютона и бисекции мы явно управляем процессом нахождения корня, используя циклы с условиями.

//    Метод Ньютона:
//        Используется для нахождения корня функции.
//        Мы итерируем, обновляя приближение корня на основе значения функции и её производной.

//    Метод бисекции:
//        Разделяет отрезок пополам и сужает его, исходя из знаков функции в концах отрезка.
//        Это более простой метод, чем метод Ньютона, но его скорость сходимости может быть медленнее.

//    Меню:
//        Программа содержит простое текстовое меню, где пользователь может выбрать метод для нахождения корня.

//Преимущества императивной парадигмы:

//    Четкое и явное управление состоянием программы.
//    Использование циклов и условий для итеративного приближения решений.
//    Возможность пошагового контроля за вычислениями, что помогает на практике (например, в численных методах).

//Этот код демонстрирует, как с помощью простых императивных конструкций можно решить задачи численного анализа.
